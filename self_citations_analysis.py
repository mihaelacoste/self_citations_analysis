# -*- coding: utf-8 -*-
"""Self-citations analysis notebook.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Thza8IO1-Ts68AVXP6rYeBKqgBqV6GXb

**Methodology**

* document type = 'REVIEW_ARTICLE', 'RESEARCH_CHAPTER', 'RESEARCH_ARTICLE' or 'CONFERENCE_PAPER'
* number of references >= 9 references
* last publication year >= 2023 (active researchers)

We only conisder researchers with at least 5 eligible publications.

**A self-citation (at the paper level) is defined as any cited paper that includes at least one author who is also an author of the citing paper.**

**Example 1:**
Main researcher A
Publication has author A,B
References are R1 (authors:A,X) and R2 (authors: Y,Z)
This is a self-citation because A is also author of R1

**Example 2:**
Main researcher A
Publication has author A,B
References are R1 (authors:B,X) and R2 (authors: Y,Z)
This is a self-citation because B is author of reference even though A, the main researcher we investigate is not author of any references

**Example 3:**
Main researcher A
Publication has author A,B
References are R1 (authors:Y,X) and R2 (authors: Y,Z)
This is not a self-citation because neither A nor B are authors of any of the references.

**GBQ Connection**
"""

import requests
import pandas as pd
import json
from google.cloud import bigquery # Import the BigQuery client library

# --- Google Colab Authentication and GBQ Helper Functions ---
from google.colab import auth
from google.auth import default

# Authenticate with Google (required for Colab environment)
auth.authenticate_user()

# Authorize gspread with authenticated credentials (if gspread operations are needed elsewhere)
creds, _ = default()

def gbq(query, project_id='your-anonymized-project'):
    """
    Executes a Google BigQuery SQL query and returns the results as a Pandas DataFrame.
    
    NOTE: The 'project_id' has been anonymized. Replace 'your-anonymized-project' 
    with the actual GBQ project ID if running this code.
    """
    client = bigquery.Client(project=project_id)
    query_job = client.query(query)
    df = query_job.to_dataframe()
    return df

"""**Distribution and Scale of Researcher Self-Citation Rates**

This analysis examines the population of researchers, quantifying the proportion of their publications that includes self-citations. It presents the full distribution of researchers across five citation ranges (0% to >75%).
"""

# SQL - self-citing publications by researcher
gbq_query_sc = f"""
select
case when pct_self_citing_pubs = 0 then '0%'
when pct_self_citing_pubs < 0.25 then '0-25%'
when pct_self_citing_pubs >=0.25 and pct_self_citing_pubs < 0.5 then '25-50%'
when pct_self_citing_pubs >= 0.5 and pct_self_citing_pubs < 0.75 then '50-75%'
when pct_self_citing_pubs >= 0.75 then '>75%' end as pct_self_citing_publications,
count(distinct researcher_id) as researchers
from `anonymized_project.citation_metrics`
group by 1
"""

results_df_sc = gbq(gbq_query_sc)

total_researchers = results_df_sc['researchers'].sum()

results_df_sc['perc_self_citing_researchers'] = (
    results_df_sc['researchers'] / total_researchers
) * 100

results_df_sc.columns = [
    'Self-Citing Publications Threshold',
    'Researchers (Count)',
    'Self-Citing Researchers %'
]

styled_table = results_df_sc.style.format({
    'Researchers (Count)': '{:,.0f}',
    'Self-Citing Researchers %': '{:.2f}%'
})

print(f"Total researchers: {total_researchers}")
print("Researcher Self-Citation Distribution:")
styled_table

"""**Field of research - level 1**

We look at the main field of research
"""

import pandas as pd

gbq_query_for_sc = f"""
select
metrics.publication_topics.most_common_for1[SAFE_OFFSET(0)].name as for_name_1,
case when pct_self_citing_pubs = 0 then '0%'
when pct_self_citing_pubs < 0.25 then '<25%'
when pct_self_citing_pubs >=0.25 and pct_self_citing_pubs < 0.5 then '25-50%'
when pct_self_citing_pubs >= 0.5 and pct_self_citing_pubs < 0.75 then '50-75%'
when pct_self_citing_pubs >= 0.75 then '>75%' end as pct_self_citing_publications,
count(distinct citations.researcher_id) as researchers
from `anonymized_project.researcher_metrics` AS metrics
left join `anonymized_project.citation_metrics` as citations on metrics.id = citations.researcher_id
where metrics.publication_topics.most_common_for1[SAFE_OFFSET(0)].name is not null
group by 1, 2
"""

results_df_for1_sc = gbq(gbq_query_for_sc)

# Calculate the total number of researchers for each Field of Research (FOR)
for_totals = results_df_for1_sc.groupby('for_name_1')['researchers'].sum().reset_index()
for_totals.columns = ['for_name_1', 'Total Researchers']

# Join the totals back and calculate the percentage for each threshold bin
results_df_for1_sc = results_df_for1_sc.merge(for_totals, on='for_name_1')
results_df_for1_sc['percentage'] = (
    results_df_for1_sc['researchers'] / results_df_for1_sc['Total Researchers']
) * 100

# Create the base Pivot Table (only percentages)
pivot_table = results_df_for1_sc.pivot_table(
    index='for_name_1',
    columns='pct_self_citing_publications',
    values='percentage'
)

# --- enforce desired bin order
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
pivot_table = pivot_table.reindex(columns=bin_cols)

# --- merge Total Researchers and set final column order ---
final_table = (
    pivot_table
    .reset_index()
    .merge(for_totals[['for_name_1', 'Total Researchers']], on='for_name_1', how='left')
    .set_index('for_name_1')
)

# put Total Researchers first, then the bins in the exact order
final_table = final_table[['Total Researchers'] + bin_cols]

# --- final cleanup ---
final_table.index.name = 'Field of Research - level 1'

# --- styling setup ---
total_researchers_col = ['Total Researchers']
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
zero_percent_col = ['0%']
other_percent_cols = ['<25%', '25-50%', '50-75%', '>75%']

styled_table = final_table.style

# Total Researchers: BLUE gradient (vertical, per column)
styled_table = styled_table.background_gradient(
    cmap='Blues',
    subset=total_researchers_col,
    axis=0
)

# 0%: RED gradient (vertical), fixed scale 0–7
styled_table = styled_table.background_gradient(
    cmap='Reds',
    subset=zero_percent_col,
    axis=0,
    vmin=0, vmax=7 # since 6 is the max value, we want it to be in dark red
)

# Other bins: same palette, fixed scale 0–100
styled_table = styled_table.background_gradient(
    cmap='YlOrRd',
    subset=other_percent_cols,
    axis=0,
    vmin=0, vmax=100
)

# Formatting
styled_table = styled_table.format({
    'Total Researchers': '{:,.0f}',
    **{col: '{:.2f}%' for col in bin_cols}
})

print("Researcher Self-Citation Distribution by Field of Research (level 1)")
styled_table

"""**Scatter plot - combined**

This chart gives an overview of the distribution of researchers across fields of research and self-citation thresholds
"""

import pandas as pd
import plotly.express as px

results_df_for1_sc['pct_self_citing_publications'] = results_df_for1_sc['pct_self_citing_publications'].astype(str)
results_df_for1_sc = results_df_for1_sc[
    ~results_df_for1_sc['pct_self_citing_publications'].isin(['None', 'nan', ''])
].copy()


facet_order = ['0%', '<25%', '25-50%', '50-75%', '>75%']

results_df_for1_sc['pct_self_citing_publications'] = pd.Categorical(
    results_df_for1_sc['pct_self_citing_publications'],
    categories=facet_order,
    ordered=True
)

facet_col_wrap = 3


# PLOTLY SCATTER PLOT
fig = px.scatter(
    results_df_for1_sc,
    x='Total Researchers',
    y='percentage',

    facet_col='pct_self_citing_publications',
    facet_col_wrap=facet_col_wrap,
    category_orders={'pct_self_citing_publications': facet_order},

    # Color & size by magnitude
    color='for_name_1',
    color_discrete_sequence=px.colors.qualitative.Bold,
    size='Total Researchers',

    hover_name='for_name_1',
    custom_data=['for_name_1', 'researchers', 'Total Researchers'],

    title='Distribution of Self-Citation Thresholds by Field Size (Color = Percentage of researchers in the bin)',
    labels={
        'Total Researchers': 'Total Researchers in FOR (Count)',
        'percentage': 'Percentage of Researchers in Bin (%)',
        'pct_self_citing_publications': 'Self-Citing Publications Threshold',
        'for_name_1': 'Field of Research'
    },
    height=800,
    width=1200
)

# Layout
fig.update_layout(
    title_font_size=18,
    hoverlabel=dict(bgcolor="white", font_size=12),

    # Use specified margins to help prevent overlap
    margin=dict(l=80, r=20, b=120, t=100),

    # Ensure X and Y axes are treated as separate entities for independent scaling
    xaxis={'matches': None},
    yaxis={'matches': None}
)

fig.update_xaxes(type="log")

fig.for_each_yaxis(lambda yaxis: yaxis.update(
    title='Researchers in Bin (%)' if yaxis.title.text else None,
    showgrid=True,
    matches=None,
    automargin=True,
    showticklabels=True
))

fig.for_each_xaxis(lambda xaxis: xaxis.update(
    title='Total Researchers' if xaxis.title.text else None,
    showticklabels=True,
    showline=True,
    automargin=True
))

fig.update_traces(
    marker=dict(
        line=dict(width=1.5, color='Black')
    ),
    text='',
    hovertemplate="<b>%{customdata[0]}</b><br>" +
                  "<br>Total FOR Researchers: %{customdata[2]:,0f}<br>" +
                  "Researchers in Bin: %{customdata[1]:,0f}<br>" +
                  "**Rate in Bin: %{y:.2f}%**" +
                  "<extra></extra>"
)

fig.show()

"""**Scatter plot - individual threshold**

This chart gives an overview of the distribution of researchers across fields of research for a selected self-citation threshold.

**Please use selected_bin to choose between 0%, <25%, 25-50%, 50-75% or >75% bins**
"""

import pandas as pd
import plotly.express as px

# --- CONFIG: choose one bin or None for all facets ---
selected_bin = "0%"    # options: "0%", "<25%", "25-50%", "50-75%", ">75%" or None

# --- prep ---
facet_order = ['0%', '<25%', '25-50%', '50-75%', '>75%']

results_df_for1_sc['pct_self_citing_publications'] = (
    results_df_for1_sc['pct_self_citing_publications'].astype(str)
)
results_df_for1_sc = results_df_for1_sc[
    ~results_df_for1_sc['pct_self_citing_publications'].isin(['None', 'nan', ''])
].copy()

results_df_for1_sc['pct_self_citing_publications'] = pd.Categorical(
    results_df_for1_sc['pct_self_citing_publications'],
    categories=facet_order,
    ordered=True
)

def make_scatter(df, title_suffix=""):
    fig = px.scatter(
        df,
        x='Total Researchers',
        y='percentage',
        color='for_name_1',                    # color by % in bin
        color_discrete_sequence=px.colors.qualitative.Bold,
        size='Total Researchers',
        hover_name='for_name_1',
        custom_data=['for_name_1', 'researchers', 'Total Researchers'],
        title=f'Distribution of Self-Citation by Field of Research {title_suffix}',
        labels={
            'Total Researchers': 'Total Researchers in FOR (Count)',
            'percentage': 'Percentage of Researchers in Bin (%)',
            'pct_self_citing_publications': 'Self-Citing Publications Threshold'
        },
        height=800,
        width=1200
    )

    # layout & axes
    fig.update_layout(
        title_font_size=18,
        hoverlabel=dict(bgcolor="white", font_size=12),
        margin=dict(l=80, r=20, b=120, t=100),
    )
    fig.update_xaxes(type="log", title='Total Researchers', showline=True, automargin=True)
    fig.update_yaxes(title='Researchers in Bin (%)', showgrid=True, automargin=True)

    # markers & hover
    fig.update_traces(
        marker=dict(line=dict(width=1.5, color='Black')),
        text='',
        hovertemplate="<b>%{customdata[0]}</b><br>" +
                      "<br>Total FOR Researchers: %{customdata[2]:,0f}<br>" +
                      "Researchers in Bin: %{customdata[1]:,0f}<br>" +
                      "**Rate in Bin: %{y:.2f}%**" +
                      "<extra></extra>"
    )
    return fig

# --- render either a single selected bin OR all facets ---
if selected_bin is not None:
    valid = set(facet_order)
    if selected_bin not in valid:
        raise ValueError(f"selected_bin must be one of {facet_order} or None.")
    df_selected = results_df_for1_sc[
        results_df_for1_sc['pct_self_citing_publications'] == selected_bin
    ]
    if df_selected.empty:
        raise ValueError(f"No data available for bin '{selected_bin}'.")
    fig = make_scatter(df_selected, title_suffix=f"(Threshold: {selected_bin})")
else:
    # Faceted overview
    facet_col_wrap = 3
    fig = px.scatter(
        results_df_for1_sc,
        x='Total Researchers',
        y='percentage',
        facet_col='pct_self_citing_publications',
        facet_col_wrap=facet_col_wrap,
        category_orders={'pct_self_citing_publications': facet_order},
        color='for_name_1',
        color_continuous_scale='Plasma',
        size='Total Researchers',
        hover_name='for_name_1',
        custom_data=['for_name_1', 'researchers', 'Total Researchers'],
        title='Distribution of Self-Citation Thresholds by Field Size (All Bins)',
        labels={
            'Total Researchers': 'Total Researchers in FOR (Count)',
            'percentage': 'Percentage of Researchers in Bin (%)',
            'pct_self_citing_publications': 'Self-Citing Publications Threshold',
            'for_name_1': 'Field of Research'
        },
        height=800,
        width=1200
    )

    fig.update_layout(
        title_font_size=18,
        hoverlabel=dict(bgcolor="white", font_size=12),
        margin=dict(l=80, r=20, b=120, t=100),
        xaxis={'matches': None},
        yaxis={'matches': None}
    )
    fig.update_xaxes(type="log")
    fig.for_each_yaxis(lambda yaxis: yaxis.update(
        title='Researchers in Bin (%)' if yaxis.title.text else None,
        showgrid=True, matches=None, automargin=True, showticklabels=True
    ))
    fig.for_each_xaxis(lambda xaxis: xaxis.update(
        title='Total Researchers' if xaxis.title.text else None,
        showticklabels=True, showline=True, automargin=True
    ))
    fig.update_traces(
        marker=dict(line=dict(width=1.5, color='Black')),
        text='',
        hovertemplate="<b>%{customdata[0]}</b><br>" +
                      "<br>Total FOR Researchers: %{customdata[2]:,0f}<br>" +
                      "Researchers in Bin: %{customdata[1]:,0f}<br>" +
                      "**Rate in Bin: %{y:.2f}%**" +
                      "<extra></extra>"
    )

fig.show()

"""**Field of Research - level 2**

We look at the main field of research (level 2)
"""

import pandas as pd

gbq_query_for2_sc = f"""
select
metrics.publication_topics.most_common_for2[SAFE_OFFSET(0)].name as for_name_2,
case when pct_self_citing_pubs = 0 then '0%'
when pct_self_citing_pubs < 0.25 then '<25%'
when pct_self_citing_pubs >=0.25 and pct_self_citing_pubs < 0.5 then '25-50%'
when pct_self_citing_pubs >= 0.5 and pct_self_citing_pubs < 0.75 then '50-75%'
when pct_self_citing_pubs >= 0.75 then '>75%' end as pct_self_citing_publications,
count(distinct citations.researcher_id) as researchers
from `anonymized_project.researcher_metrics` AS metrics
left join `anonymized_project.citation_metrics` as citations on metrics.id = citations.researcher_id
where metrics.publication_topics.most_common_for2[SAFE_OFFSET(0)].name is not null
group by 1, 2
"""

results_df_for2_sc = gbq(gbq_query_for2_sc)

# Calculate the total number of researchers for each Field of Research (FOR)
for_totals = results_df_for2_sc.groupby('for_name_2')['researchers'].sum().reset_index()
for_totals.columns = ['for_name_2', 'Total Researchers']

# Join the totals back and calculate the percentage for each threshold bin
results_df_for2_sc = results_df_for2_sc.merge(for_totals, on='for_name_2')
results_df_for2_sc['percentage'] = (
    results_df_for2_sc['researchers'] / results_df_for2_sc['Total Researchers']
) * 100

# Create the base Pivot Table (only percentages)
pivot_table = results_df_for2_sc.pivot_table(
    index='for_name_2',
    columns='pct_self_citing_publications',
    values='percentage'
)

# --- enforce desired bin order
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
pivot_table = pivot_table.reindex(columns=bin_cols)

# --- merge Total Researchers and set final column order ---
final_table = (
    pivot_table
    .reset_index()
    .merge(for_totals[['for_name_2', 'Total Researchers']], on='for_name_2', how='left')
    .set_index('for_name_2')
)

# put Total Researchers first, then the bins in the exact order
final_table = final_table[['Total Researchers'] + bin_cols]

# --- final cleanup ---
final_table.index.name = 'Field of Research - level 1'

# --- styling setup ---
total_researchers_col = ['Total Researchers']
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
zero_percent_col = ['0%']
other_percent_cols = ['<25%', '25-50%', '50-75%', '>75%']

styled_table = final_table.style

# Total Researchers: BLUE gradient (vertical, per column)
styled_table = styled_table.background_gradient(
    cmap='Blues',
    subset=total_researchers_col,
    axis=0
)

# 0%: RED gradient (vertical), fixed scale 0–7
styled_table = styled_table.background_gradient(
    cmap='Reds',
    subset=zero_percent_col,
    axis=0,
    vmin=0, vmax=7 # since 6 is the max value, we want it to be in dark red
)

# Other bins: same palette, fixed scale 0–100
styled_table = styled_table.background_gradient(
    cmap='YlOrRd',
    subset=other_percent_cols,
    axis=0,
    vmin=0, vmax=100
)

# Formatting
styled_table = styled_table.format({
    'Total Researchers': '{:,.0f}',
    **{col: '{:.2f}%' for col in bin_cols}
})

print("Researcher Self-Citation Distribution by Field of Research (level 1)")
styled_table

"""**Academic Age**"""

import pandas as pd

gbq_query_age = f"""
SELECT
  CASE
    WHEN metrics.publications.academic_age < 1 THEN 'Below 1'
    WHEN metrics.publications.academic_age >= 1  AND metrics.publications.academic_age < 6  THEN '1 to 5'
    WHEN metrics.publications.academic_age >= 6  AND metrics.publications.academic_age < 11 THEN '6 to 10'
    WHEN metrics.publications.academic_age >= 11 AND metrics.publications.academic_age < 16 THEN '11 to 15'
    WHEN metrics.publications.academic_age >= 16 AND metrics.publications.academic_age < 20 THEN '16 to 20'
    WHEN metrics.publications.academic_age >= 21 AND metrics.publications.academic_age < 26 THEN '21 to 25'
    WHEN metrics.publications.academic_age >= 26 AND metrics.publications.academic_age < 31 THEN '26 to 30'
    WHEN metrics.publications.academic_age >= 31 AND metrics.publications.academic_age < 36 THEN '31 to 35'
    WHEN metrics.publications.academic_age >= 36 AND metrics.publications.academic_age < 41 THEN '36 to 40'
    WHEN metrics.publications.academic_age >= 41 THEN '41 or Above'
    ELSE 'Undefined'
  END AS academic_age,
  CASE
    WHEN pct_self_citing_pubs = 0 THEN '0%'
    WHEN pct_self_citing_pubs < 0.25 THEN '<25%'
    WHEN pct_self_citing_pubs >= 0.25 AND pct_self_citing_pubs < 0.5 THEN '25-50%'
    WHEN pct_self_citing_pubs >= 0.5 AND pct_self_citing_pubs < 0.75 THEN '50-75%'
    WHEN pct_self_citing_pubs >= 0.75 THEN '>75%'
  END AS pct_self_citing_publications,
  COUNT(DISTINCT citations.researcher_id) AS researchers
FROM `anonymized_project.researcher_metrics` AS metrics
LEFT JOIN `anonymized_project.citation_metrics` AS citations
  ON metrics.id = citations.researcher_id
GROUP BY 1, 2
"""

results_df_age = gbq(gbq_query_age)

# Academic Age order
age_order = [
    'Below 1','1 to 5','6 to 10','11 to 15','16 to 20',
    '21 to 25','26 to 30','31 to 35','36 to 40','41 or Above'
]

results_df_age = results_df_age.copy()
results_df_age['academic_age'] = results_df_age['academic_age'].astype(str)
results_df_age = results_df_age[results_df_age['academic_age'].isin(age_order)].copy()
results_df_age['academic_age'] = pd.Categorical(results_df_age['academic_age'], categories=age_order, ordered=True)

# Totals per Academic Age
age_totals = results_df_age.groupby('academic_age', observed=True)['researchers'].sum().reset_index()
age_totals.columns = ['Academic Age', 'Total Researchers']

# percentages within each Academic Age
results_df_age = results_df_age.merge(age_totals.rename(columns={'Academic Age':'academic_age'}), on='academic_age', how='left')
results_df_age['percentage'] = (results_df_age['researchers'] / results_df_age['Total Researchers']) * 100

# Pivot (Academic Age rows; threshold columns)
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']

pivot_table = results_df_age.pivot_table(
    index='academic_age',
    columns='pct_self_citing_publications',
    values='percentage'
).reindex(index=age_order, columns=bin_cols)

# Bring Academic Age as a column and merge totals
final_table = (
    pivot_table
    .reset_index()
    .rename(columns={'academic_age': 'Academic Age'})
    .merge(age_totals, on='Academic Age', how='left')
)

# Column order: Academic Age (col 1), Total Researchers (col 2), then thresholds
final_table = final_table[['Academic Age', 'Total Researchers'] + bin_cols]

# Styling
styled_table = final_table.style

# Blues for Total Researchers (vertical)
styled_table = styled_table.background_gradient(
    cmap='Blues', subset=['Total Researchers'], axis=0
)

# Reds for 0% (vertical)
styled_table = styled_table.background_gradient(
    cmap='Reds', subset=['0%'], axis=0, vmin=0, vmax=100
)

# YlOrRd for the other thresholds (vertical), 0–100 for comparable intensity
styled_table = styled_table.background_gradient(
    cmap='YlOrRd', subset=['<25%', '25-50%', '50-75%', '>75%'], axis=0, vmin=0, vmax=100
)

# Formats
styled_table = styled_table.format({
    'Total Researchers': '{:,.0f}',
    **{col: '{:.2f}%' for col in bin_cols}
})

print("Researcher Self-Citation Distribution by Academic Age")
styled_table

"""**STEM vs. Hummanities**"""

import pandas as pd

gbq_query_for_sc = f"""
SELECT
    -- New CASE WHEN for STEM vs HASS categorization
    CASE
        -- Define Humanities/Social Sciences (HASS) Categories
        WHEN metrics.publication_topics.most_common_for1[SAFE_OFFSET(0)].name IN (
            'Creative Arts and Writing',
            'Law and Legal Studies',
            'Commerce, Management, Tourism and Services',
            'Education',
            'Language, Communication and Culture',
            'Philosophy and Religious Studies',
            'Economics',
            'Human Society',
            'Psychology',
            'History, Heritage and Archaeology',
            'Built Environment and Design'
            -- All other humanities/social science FoRs would be added here
        ) THEN 'HASS'
        -- Everything else (Physical Sciences, Life Sciences, Technology, Health) is STEM
        ELSE 'STEM'
    END AS for_name_1,

    -- Your existing CASE WHEN for self-citation bins
    CASE
        WHEN pct_self_citing_pubs = 0 THEN '0%'
        WHEN pct_self_citing_pubs < 0.25 THEN '<25%'
        WHEN pct_self_citing_pubs >= 0.25 AND pct_self_citing_pubs < 0.5 THEN '25-50%'
        WHEN pct_self_citing_pubs >= 0.5 AND pct_self_citing_pubs < 0.75 THEN '50-75%'
        WHEN pct_self_citing_pubs >= 0.75 THEN '>75%'
    END AS pct_self_citing_publications,

    COUNT(DISTINCT citations.researcher_id) AS researchers
FROM
    `anonymized_project.researcher_metrics` AS metrics
LEFT JOIN
    `anonymized_project.citation_metrics` AS citations
    ON metrics.id = citations.researcher_id
WHERE
    metrics.publication_topics.most_common_for1[SAFE_OFFSET(0)].name IS NOT NULL
GROUP BY
    1, 2 -- Grouping by the new research_cluster (1) and the self-citation bin (2)
"""

results_df_for1_sc = gbq(gbq_query_for_sc)

# Calculate the total number of researchers for each Field of Research (FOR)
for_totals = results_df_for1_sc.groupby('for_name_1')['researchers'].sum().reset_index()
for_totals.columns = ['for_name_1', 'Total Researchers']

# Join the totals back and calculate the percentage for each threshold bin
results_df_for1_sc = results_df_for1_sc.merge(for_totals, on='for_name_1')
results_df_for1_sc['percentage'] = (
    results_df_for1_sc['researchers'] / results_df_for1_sc['Total Researchers']
) * 100

# Create the base Pivot Table (only percentages)
pivot_table = results_df_for1_sc.pivot_table(
    index='for_name_1',
    columns='pct_self_citing_publications',
    values='percentage'
)

# --- enforce desired bin order
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
pivot_table = pivot_table.reindex(columns=bin_cols)

# --- merge Total Researchers and set final column order ---
final_table = (
    pivot_table
    .reset_index()
    .merge(for_totals[['for_name_1', 'Total Researchers']], on='for_name_1', how='left')
    .set_index('for_name_1')
)

# put Total Researchers first, then the bins in the exact order
final_table = final_table[['Total Researchers'] + bin_cols]

# --- final cleanup ---
final_table.index.name = 'Field of Research - level 1'

# --- styling setup ---
total_researchers_col = ['Total Researchers']
bin_cols = ['0%', '<25%', '25-50%', '50-75%', '>75%']
zero_percent_col = ['0%']
other_percent_cols = ['<25%', '25-50%', '50-75%', '>75%']

styled_table = final_table.style

# Total Researchers: BLUE gradient (vertical, per column)
styled_table = styled_table.background_gradient(
    cmap='Blues',
    subset=total_researchers_col,
    axis=0
)

# 0%: RED gradient (vertical), fixed scale 0–7
styled_table = styled_table.background_gradient(
    cmap='Reds',
    subset=zero_percent_col,
    axis=0,
    vmin=0, vmax=7 # since 6 is the max value, we want it to be in dark red
)

# Other bins: same palette, fixed scale 0–100
styled_table = styled_table.background_gradient(
    cmap='YlOrRd',
    subset=other_percent_cols,
    axis=0,
    vmin=0, vmax=100
)

# Formatting
styled_table = styled_table.format({
    'Total Researchers': '{:,.0f}',
    **{col: '{:.2f}%' for col in bin_cols}
})

print("Researcher Self-Citation Distribution by Field of Research (level 1)")
styled_table
